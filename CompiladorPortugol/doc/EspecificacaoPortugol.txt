
Helpers

		all 			= [0 .. 0xffff];
		letter 			= ['a' .. 'z'] | ['A' .. 'Z'];
		digit 			= ['0' .. '9'];

States 

		normal, comment;

Tokens

		// Palavras reservadas
		{normal} programa 		= 'programa';
		{normal} inicio 		= 'inicio';
		{normal} fim 			= 'fim.';
		{normal} escreva		= 'escreva';
		{normal} leia			= 'leia';
		{normal} enquanto 		= 'enquanto';
		{normal} fim_enquanto	= 'fim enquanto';
		{normal} se 			= 'se';
		{normal} entao 			= 'entao';
		{normal} senao 			= 'senao';
		{normal} fim_se 		= 'fim se';
		{normal} para 			= 'para';
		{normal} de				= 'de';
		{normal} passo			= 'passo';
		{normal} fim_para 		= 'fim para';
		{normal} ate 			= 'ate';
		{normal} faca 			= 'faca';
		{normal} repita 		= 'repita';
		{normal} avalie			= 'avalie';
		{normal} caso 			= 'caso';
		{normal} fim_avalie 	= 'fim avalie';
		{normal} const			= 'const';
		{normal} tipo 			= 'inteiro' | 'real' | 'caractere';

		// Operadores
		{normal} mais 			= '+';
		{normal} menos 			= '-';
		{normal} divisao 		= '/';
		{normal} mult 			= '*';
		{normal} igual			= '=';
		{normal} diferente		= '<>';
		{normal} maior			= '>';
		{normal} menor			= '<';
		{normal} menor_igual	= '<=';
		{normal} maior_igual	= '>=';
		{normal} e				= 'e';
		{normal} ou				= 'ou';
		{normal} xor			= 'xor';
		{normal} nao			= 'nao';
		{normal} atribuicao		= '<-';

		// Símbolos
		{normal} par_d 			= ')';
		{normal} par_e 			= '(';
		{normal} col_d			= ']';
		{normal} col_e			= '[';
		{normal} ponto 			= '.';
		{normal} virgula		= ',';
		{normal} dois_pontos 	= ':';
		{normal} semicolon	 	= ';';


		// Identificador
		{normal} id 			= ('_' | letter)(letter | digit | '_')*;
		{normal} id_array 		= ('_' | letter)(letter | digit | '_')*('[' digit+ ']');
		
		// Tipos
		{normal} n_int 			= digit+;
		{normal} n_real 		= digit* '.' digit+ ('E' ('-' | '+')? digit+)?;
		{normal} string			= ''' [all - [ 9 + [13 + '''] ]]* ''';
		
		// Comentários		
		{normal} comment_line			   = '//'[all-10]*10;
		{normal->comment, comment} comment = '/*';
		{comment} comment_end 			   = '*/'; 
		{comment} comment_body 			   = [all - ['*' + '/']]*; 
		{comment} star 					   = '*'; 
		{comment} slash 				   = '/';
		
		{normal} blank 			= (' '| 9 | 10 | 13)+;

Ignored Tokens

		blank, comment, comment_line;
		
Productions

		start = {start} program;
		
		program = {program} programa id inicio decl* command* fim;
		
		decl = 
			{variable} tipo dois_pontos varlist* var semicolon | 
			{constant} const id valor;
				
		var = 
			{id} id | 
			{id_array} id_array;
		
		varlist = var virgula;
		
		valor = 
			{string} string | 
			{integer} n_int | 
			{real} n_real;
		
		command = 
			{attribution} 	var atribuicao exp semicolon |
			
			{read} 			leia par_e varlist* var par_d semicolon | 
			
			{write}			escreva par_e explist* exp par_d semicolon |
			
			{if} 			se par_e explogic par_d entao command+ elsepart? fim_se semicolon |
			
			{switch}		avalie par_e exp par_d casepart+ elseswitch? fim_avalie semicolon |
			
			{while}			enquanto par_e explogic par_d faca command+ fim_enquanto semicolon |
			
			{repeat} 		repita command+ ate par_e explogic par_d semicolon |
			
			{for}			para var de [x1]:n_int ate [x2]:n_int faca command+ fim_para semicolon |
			
			{for_passo}		para var de [x1]:n_int passo [x2]:n_int ate [x3]:n_int faca command+ fim_para semicolon;
			
		
		elsepart = senao command+;
		
		casepart = caso valor dois_pontos command+;
		
		elseswitch = senao dois_pontos command+;

		exp =
			{exp_sum} exp mais term |
			{exp_sub} exp menos term |
			{exp_term} term ;
		
		explist = exp virgula;
		
		term = 
			{term_mult} term mult factor |
			{term_div} term divisao factor |
			{term_factor} factor;
		
		factor= 
			{valor} valor |
			{var} var |
			{par_exp} par_e exp par_d;// |
			//{logic} explogic;
			
			
		explogic = 
				{or} exp ou termlogic | 
				{xor} exp xor termlogic | 
				{term_logic} termlogic;
		
		termlogic = 
				{and} termlogic e factorlogic |
				{factor_logic} factorlogic;
				
		factorlogic =
				{not} nao exprelational |
				{par_exp} par_e explogic par_d |
				{exp_relational} exprelational;
		
		exprelational = [exp1]:exp operator [exp2]:exp ;
		
		operator = 
				{igual} igual |
				{diferente} diferente |
				{maior} maior |
				{menor} menor |
				{maior_igual} maior_igual |
				{menor_igual} menor_igual;
			


